在 Java 中，方法存在重载以及重写的概念，重载指的是方法名相同而参数类型不相同的方法之间的关系，重写指的是方法名相同并且参数类型也相同的方法之间的关系。

重载:同类重载，继承重载
重写：继承重写
如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型不同，那么在子类中，这两个方法同样构成了重载。

如果子类定义了与父类中非私有方法同名的方法，而且这两个方法的参数类型相同，那么这两个方法之间又是什么关系呢？
如果这两个方法都是静态的，那么子类中的方法隐藏了父类中的方法。如果这两个方法都不是静态的，且都不是私有的，那么子类的方法重写了父类中的方法。

java语法和jvm规范对于重载和重写的限制区别

Java 虚拟机识别方法的关键在于类名、方法名以及方法描述符（method descriptor）
方法描述符，它是由方法的参数类型以及返回类型所构成。在同一个类中，如果同时出现多个名字相同且描述符也相同的方法，那么 Java 虚拟机会在类的验证阶段报错。

Java 虚拟机与 Java 语言不同，它并不限制名字与参数类型相同，但返回类型不同的方法出现在同一个类中，对于调用这些方法的字节码来说，
由于字节码所附带的方法描述符包含了返回类型，因此 Java 虚拟机能够准确地识别目标方法。

对于 Java 语言中重写而 Java 虚拟机中非重写的情况，编译器会通过生成桥接方法来实现 Java 中的重写语义。

![images/jvm/bridge.png]()

flags: ACC_PUBLIC, ACC_BRIDGE, ACC_SYNTHETIC
ACC_BRIDGE：表示这个一个桥接方法
ACC_SYNTHETIC：表示这个方法由编译器自动生成
public com.learn.java8.jvm.C test(java.lang.String);

子类在继承父类的一个泛型方法、或子类实现一个接口的泛型方法，编译器会在子类的 class 文件中自动生成桥接方法。


java 语法中重写：对于父子类同个方法，同参数类型，返回值也是父子关系，这种情况java语法也判断为重写（类ABCD可以验证该结论）
而虚拟机严格控制要求返回值类型必须相同

由于 Java 编译器已经区分了重载的方法，因此可以认为 Java 虚拟机中不存在重载。
由于对重载方法的区分在编译阶段已经完成，我们可以认为 Java 虚拟机不存在重载这一概念。
因此，在某些文章中，重载也被称为静态绑定（static binding），
或者编译时多态（compile-time polymorphism）；而重写则被称为动态绑定（dynamic binding）。
这个说法在 Java 虚拟机语境下并非完全正确。这是因为某个类中的重载方法可能被它的子类所重写，因此 Java 编译器会将所有对非私有实例方法的调用编译为需要动态绑定的类型。

确切地说，Java 虚拟机中的静态绑定指的是在解析时便能够直接识别目标方法的情况，而动态绑定则指的是需要在运行过程中根据调用者的动态类型来识别目标方法的情况。

Java 字节码中与调用相关的指令共有五种。
invokestatic：用于调用静态方法。
invokespecial：用于调用私有实例方法(eg:private setName())、构造器，以及使用 super 关键字调用父类的实例方法或构造器，和所实现接口的默认方法(default)。
invokevirtual：用于调用非私有实例方法。 eg:public setName()
invokeinterface：用于调用接口方法。
invokedynamic：用于调用动态方法。

对于 invokestatic 以及 invokespecial 而言，Java 虚拟机能够直接识别具体的目标方法。
而对于 invokevirtual 以及 invokeinterface 而言，在绝大部分情况下，虚拟机需要在执行过程中，根据调用者的动态类型，来确定具体的目标方法。
唯一的例外在于，如果虚拟机能够确定目标方法有且仅有一个，比如说目标方法被标记为 final[3][4]，那么它可以不通过动态类型，直接确定目标方法。

静态方法不能被继承(也不能被重写)，编译时就可以直接确定调用


对于非接口符号引用，假定该符号引用所指向的类为 C，则 Java 虚拟机会按照如下步骤进行查找。
在 C 中查找符合名字及描述符的方法。
如果没有找到，在 C 的父类中继续搜索，直至 Object 类。
如果没有找到，在 C 所直接实现或间接实现的接口中搜索，这一步搜索得到的目标方法必须是非私有、非静态的。
并且，如果目标方法在间接实现的接口中，则需满足 C 与该接口之间没有其他符合条件的目标方法。如果有多个符合条件的目标方法，则任意返回其中一个。

从这个解析算法可以看出，静态方法也可以通过子类来调用。此外，子类的静态方法会隐藏（注意与重写区分）父类中的同名、同描述符的静态方法。

对于接口符号引用，假定该符号引用所指向的接口为 I，则 Java 虚拟机会按照如下步骤进行查找。
在 I 中查找符合名字及描述符的方法。
如果没有找到，在 Object 类中的公有实例方法中搜索。
如果没有找到，则在 I 的超接口中搜索。这一步的搜索结果的要求与非接口符号引用步骤 3 的要求一致。

经过上述的解析步骤之后，符号引用会被解析成实际引用。对于可以静态绑定的方法调用而言，实际引用是一个指向方法的指针。对于需要动态绑定的方法调用而言，实际引用则是一个方法表的索引。